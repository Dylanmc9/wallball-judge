<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Wall Ball Judge</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{
      --blue: #1e90ff;
      --red: #ff5a5a;
      --glassBorder: rgba(255,255,255,0.18);
      --textDim: rgba(255,255,255,0.85);
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #000;
      color: white;
      overflow: hidden;
    }

    #videoContainer {
      position: fixed;
      inset: 0;
      overflow: hidden;
      background: #000;
    }

    video, canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      transform: translate(-50%, -50%);
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 12px;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: space-between;
      background: rgba(0,0,0,0.35);
      box-sizing: border-box;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    #repCount {
      font-size: 1.2rem;
      font-weight: 800;
      display: flex;
      flex-direction: column;
      gap: 2px;
      white-space: nowrap;
    }

    #repCount small {
      font-size: 0.9rem;
      opacity: 0.85;
      font-weight: 600;
    }

    #controls {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    #feedback {
      font-size: 1.05rem;
      opacity: 0.95;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 40vw;
      text-align: right;
      margin-left: auto;
    }

    .btn {
      padding: 9px 12px;
      font-size: 0.9rem;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      white-space: nowrap;
      color: #fff;
    }

    .btn.primary { background: var(--blue); }
    .btn.secondary {
      background: rgba(255,255,255,0.18);
      border: 1px solid rgba(255,255,255,0.35);
    }
    .btn.danger { background: var(--red); }

    /* ===== Start Screen (new.png style) ===== */
    #startScreen {
      position: absolute;
      inset: 0;
      z-index: 20;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 18px;
      box-sizing: border-box;

      background:
        radial-gradient(85% 70% at 15% 20%, rgba(0, 255, 140, 0.22), transparent 60%),
        radial-gradient(85% 70% at 85% 30%, rgba(0, 255, 140, 0.18), transparent 62%),
        radial-gradient(90% 75% at 60% 90%, rgba(0, 255, 140, 0.14), transparent 55%),
        rgba(0,0,0,0.86);
    }

    .startCard {
      width: min(520px, 92vw);
      border-radius: 26px;
      padding: 34px 22px;
      text-align: center;

      background: linear-gradient(
        180deg,
        rgba(50,50,50,0.42) 0%,
        rgba(18,18,18,0.34) 100%
      );
      border: 1px solid var(--glassBorder);
      box-shadow:
        0 18px 60px rgba(0,0,0,0.55),
        inset 0 1px 0 rgba(255,255,255,0.10);

      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .startTitle {
      font-size: 2.1rem;
      font-weight: 800;
      margin-bottom: 16px;
    }

    .startTip {
      margin: 0 auto 28px auto;
      max-width: 420px;
      font-size: 1.05rem;
      line-height: 1.45;
      color: var(--textDim);
    }

    .startTip strong {
      font-weight: 800;
      color: rgba(255,255,255,0.95);
    }

    .pillStack {
      display: flex;
      flex-direction: column;
      gap: 14px;
      align-items: center;
    }

    .pillBtn {
      width: min(360px, 78vw);
      padding: 14px 18px;
      border-radius: 999px;
      font-size: 1.15rem;
      font-weight: 700;
      color: #fff;
      background: rgba(0,0,0,0.18);
      border: 2px solid rgba(255,255,255,0.90);
      cursor: pointer;
      outline: none;
      transition: transform 0.08s ease, background 0.12s ease;
    }

    .pillBtn:active {
      transform: scale(0.99);
      background: rgba(255,255,255,0.06);
    }

    .hintLine {
      margin-top: 16px;
      font-size: 0.95rem;
      color: rgba(255,255,255,0.65);
    }
  </style>
</head>

<body>
<div id="videoContainer">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="overlay">
    <div id="repCount">
      <span id="repsText">Reps: 0</span>
      <small id="breakdownText">Good: 0 • No: 0</small>
    </div>

    <div id="controls">
      <button id="targetMissBtn" class="btn danger" type="button">Target Miss</button>
      <button id="resetBtn" class="btn secondary" type="button">Reset</button>
      <button id="flipBtn" class="btn primary" type="button">Flip</button>
    </div>

    <div id="feedback">Ready</div>
  </div>

  <div id="startScreen">
    <div class="startCard">
      <div class="startTitle">Select Division</div>
      <p class="startTip">
        Tip: place your phone so your full body is visible.
        <br><strong>Rear camera gives best tracking.</strong>
      </p>
      <div class="pillStack">
        <button class="pillBtn" onclick="startApp('women')">Women</button>
        <button class="pillBtn" onclick="startApp('men')">Men</button>
      </div>
      <div class="hintLine">Depth decides rep. Throw motion only separates reps.</div>
    </div>
  </div>
</div>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const repsText = document.getElementById("repsText");
  const breakdownText = document.getElementById("breakdownText");
  const feedbackEl = document.getElementById("feedback");
  const startScreen = document.getElementById("startScreen");

  const flipBtn = document.getElementById("flipBtn");
  const resetBtn = document.getElementById("resetBtn");
  const targetMissBtn = document.getElementById("targetMissBtn");

  // ==========================
  // TUNING
  // ==========================
  // Depth is "hip below knee by X pixels"
  const DEPTH_MARGIN_PX = 18;      // lower = easier, higher = stricter

  // Wrist movement is ONLY used to separate reps (timing)
  const THROW_LINE_RATIO = 0.35;   // wrists above this = "throw moment"
  const RESET_LINE_RATIO = 0.55;   // wrists below this = ready for next throw
  const MIN_TIME_BETWEEN_REPS_MS = 450;

  // ==========================
  // Rep state
  // ==========================
  let reps = 0;
  let goodReps = 0;
  let noReps = 0;

  let depthReachedThisCycle = false;

  let throwHigh = false;
  let lastRepTime = 0;

  // Camera/pose state
  let currentFacing = "environment";
  let currentStream = null;
  let pose = null;

  let rafId = null;
  let isProcessing = false;
  let started = false;

  function updateCounters() {
    repsText.textContent = `Reps: ${reps}`;
    breakdownText.textContent = `Good: ${goodReps} • No: ${noReps}`;
  }

  function resetCycleOnly() {
    // Keep counters, but reset the “current rep window”
    depthReachedThisCycle = false;
    throwHigh = false;
  }

  function hardResetCounts() {
    reps = 0;
    goodReps = 0;
    noReps = 0;

    depthReachedThisCycle = false;
    throwHigh = false;
    lastRepTime = 0;

    feedbackEl.textContent = "Reset ✅";
    updateCounters();
  }

  resetBtn.addEventListener("click", hardResetCounts);

  targetMissBtn.addEventListener("click", () => {
    // Manual judge override: counts as a rep attempt and a no-rep
    reps += 1;
    noReps += 1;

    feedbackEl.textContent = "NO REP ❌ (target miss)";
    updateCounters();

    // Don’t let it immediately auto-count from the same throw motion
    lastRepTime = Date.now();
    resetCycleOnly();
  });

  function startApp(division) {
    // Division currently not used (kept for future). App logic is identical either way.
    startScreen.style.display = "none";
    started = true;

    updateCounters();
    initPoseOnce();
    startWithFacing("environment");
  }

  function initPoseOnce() {
    if (pose) return;

    pose = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    pose.onResults(onResults);
  }

  function stopLoop() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }

  function stopStream() {
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
    }
  }

  async function startWithFacing(facing) {
    stopLoop();
    stopStream();

    feedbackEl.textContent = "Switching...";

    const tryConstraints = [
      { video: { facingMode: { exact: facing }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
      { video: { facingMode: { ideal: facing }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
    ];

    let stream = null;
    let lastErr = null;

    for (const c of tryConstraints) {
      try {
        stream = await navigator.mediaDevices.getUserMedia(c);
        break;
      } catch (e) {
        lastErr = e;
      }
    }

    if (!stream) {
      if (facing === "environment") {
        feedbackEl.textContent = "Rear blocked — using front";
        return startWithFacing("user");
      }
      feedbackEl.textContent = "Camera error";
      console.error(lastErr);
      return;
    }

    currentStream = stream;
    video.srcObject = currentStream;

    try { await video.play(); } catch (_) {}

    currentFacing = facing;
    feedbackEl.textContent = `Camera: ${currentFacing === "environment" ? "Rear" : "Front"}`;

    resetCycleOnly();
    runLoop();
  }

  function runLoop() {
    const tick = async () => {
      rafId = requestAnimationFrame(tick);

      if (!pose || !started) return;
      if (isProcessing) return;
      if (video.readyState < 2) return;

      isProcessing = true;
      try {
        await pose.send({ image: video });
      } catch (e) {
        // ignore transient iOS errors
      } finally {
        isProcessing = false;
      }
    };
    tick();
  }

  flipBtn.addEventListener("click", async () => {
    if (!started) return;
    const next = (currentFacing === "environment") ? "user" : "environment";
    await startWithFacing(next);
  });

  function onResults(results) {
    if (!video.videoWidth || !video.videoHeight) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

    if (!results.poseLandmarks) {
      feedbackEl.textContent = "No person detected";
      return;
    }

    const lm = results.poseLandmarks;

    // ---- Depth line + hip marker ----
    const leftHipY  = lm[23].y * canvas.height;
    const rightHipY = lm[24].y * canvas.height;
    const leftKneeY = lm[25].y * canvas.height;
    const rightKneeY= lm[26].y * canvas.height;

    const hipY  = Math.max(leftHipY, rightHipY);
    const kneeY = Math.max(leftKneeY, rightKneeY);

    const depthGoodNow = hipY > (kneeY + DEPTH_MARGIN_PX);
    if (depthGoodNow) depthReachedThisCycle = true;

    // Knee line: turns green once depth has been hit during this cycle
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = 6;
    ctx.strokeStyle = depthReachedThisCycle ? "rgba(0,255,140,0.95)" : "rgba(255,255,255,0.55)";
    ctx.moveTo(0, kneeY);
    ctx.lineTo(canvas.width, kneeY);
    ctx.stroke();

    // Hip dot: green if currently deep enough, red otherwise
    const hipX = ((lm[23].x + lm[24].x) / 2) * canvas.width;
    ctx.beginPath();
    ctx.fillStyle = depthGoodNow ? "rgba(0,255,140,0.95)" : "rgba(255,80,80,0.95)";
    ctx.arc(hipX, hipY, 10, 0, Math.PI * 2);
    ctx.fill();

    // Depth label
    ctx.font = "bold 28px system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.fillStyle = depthGoodNow ? "rgba(0,255,140,0.95)" : "rgba(255,255,255,0.8)";
    ctx.fillText(depthGoodNow ? "DEPTH ✅" : "DEPTH ⛔", 18, 44);
    ctx.restore();

    // ---- Rep separation using wrists (timing only) ----
    const leftWristY = lm[15].y * canvas.height;
    const rightWristY = lm[16].y * canvas.height;
    const wristY = Math.min(leftWristY, rightWristY);

    const throwLineY = canvas.height * THROW_LINE_RATIO;
    const resetLineY = canvas.height * RESET_LINE_RATIO;

    const now = Date.now();

    // Evaluate at "throw moment"
    if (!throwHigh && wristY < throwLineY) {
      if (now - lastRepTime > MIN_TIME_BETWEEN_REPS_MS) {
        reps += 1;

        if (depthReachedThisCycle) {
          goodReps += 1;
          feedbackEl.textContent = "GOOD REP ✅ (depth reached)";
        } else {
          noReps += 1;
          feedbackEl.textContent = "NO REP ❌ (depth not reached)";
        }

        updateCounters();

        throwHigh = true;
        lastRepTime = now;

        // Reset for next rep cycle immediately (continuous)
        depthReachedThisCycle = false;
      }
    }

    // Ready for next rep once wrists come back down
    if (throwHigh && wristY > resetLineY) {
      throwHigh = false;
    }

    // Skeleton overlay (optional)
    drawConnectors(ctx, lm, POSE_CONNECTIONS, { color: "#00FF00", lineWidth: 2 });
    drawLandmarks(ctx, lm, { color: "#FF0000", lineWidth: 1 });
  }
</script>
</body>
</html>
