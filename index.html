<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Wall Ball Judge</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{
      --blue: #1e90ff;
      --red: rgba(255, 90, 90, 0.95);
      --glass: rgba(255,255,255,0.10);
      --glass2: rgba(255,255,255,0.06);
      --glassBorder: rgba(255,255,255,0.18);
      --textDim: rgba(255,255,255,0.78);

      --greenFlash: rgba(0, 255, 140, 0.25);
      --redFlash: rgba(255, 60, 60, 0.22);
    }

    /* Premium-ish system stack */
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial;
      background: #000;
      color: #fff;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
      letter-spacing: 0.1px;
    }

    #videoContainer {
      position: fixed;
      inset: 0;
      overflow: hidden;
      background: #000;
    }

    video, canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      transform: translate(-50%, -50%);
    }

    /* ===== Fullscreen flash (subtle) ===== */
    #flash {
      position: absolute;
      inset: 0;
      z-index: 30;
      pointer-events: none;
      opacity: 0;
    }
    @keyframes flashAnim {
      0% { opacity: 0; }
      18% { opacity: 1; }
      100% { opacity: 0; }
    }
    #flash.flash { animation: flashAnim 240ms ease-out; }

    /* ===== Minimal top HUD ===== */
    #hud {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      z-index: 40;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      pointer-events: none; /* buttons re-enable below */
    }

    #counters {
      pointer-events: none;
      padding: 10px 12px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.16);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      min-width: 130px;
    }

    #counters .big {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.2px;
      line-height: 1.05;
    }
    #counters .small {
      margin-top: 6px;
      font-size: 14px;
      color: var(--textDim);
      font-weight: 600;
      letter-spacing: 0.15px;
    }

    #controls {
      pointer-events: auto;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .glassBtn {
      padding: 10px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.05));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.92);
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.2px;
      cursor: pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
      transition: transform 0.08s ease, background 0.12s ease, border 0.12s ease;
      user-select: none;
    }
    .glassBtn:active { transform: scale(0.99); }
    .glassBtn.blue {
      background: linear-gradient(180deg, rgba(30,144,255,0.65), rgba(30,144,255,0.35));
      border-color: rgba(30,144,255,0.35);
    }
    .glassBtn.red {
      background: linear-gradient(180deg, rgba(255,90,90,0.62), rgba(255,90,90,0.28));
      border-color: rgba(255,90,90,0.35);
    }

    /* ===== Big centered feedback badge ===== */
    #badgeWrap {
      position: absolute;
      inset: 0;
      z-index: 45;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    #badge {
      opacity: 0;
      transform: translateY(8px) scale(0.985);
      padding: 14px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 20px 60px rgba(0,0,0,0.55);
      font-weight: 900;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      font-size: 22px;
      color: rgba(255,255,255,0.92);
    }

    @keyframes badgeInOut {
      0%   { opacity: 0; transform: translateY(10px) scale(0.98); }
      12%  { opacity: 1; transform: translateY(0) scale(1.00); }
      80%  { opacity: 1; transform: translateY(0) scale(1.00); }
      100% { opacity: 0; transform: translateY(8px) scale(0.99); }
    }
    #badge.show { animation: badgeInOut 900ms ease-out; }
    #badge.good { border-color: rgba(0,255,140,0.35); background: rgba(0,255,140,0.12); }
    #badge.bad  { border-color: rgba(255,60,60,0.40); background: rgba(255,60,60,0.10); }

    /* ===== Start screen ===== */
    #startScreen {
      position: absolute;
      inset: 0;
      z-index: 50;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 18px;
      box-sizing: border-box;

      background:
        radial-gradient(85% 70% at 15% 20%, rgba(0, 255, 140, 0.18), transparent 60%),
        radial-gradient(85% 70% at 85% 30%, rgba(0, 255, 140, 0.14), transparent 62%),
        radial-gradient(90% 75% at 60% 90%, rgba(0, 255, 140, 0.12), transparent 55%),
        rgba(0,0,0,0.88);
    }

    /* Logo like your screenshot */
    .logo {
      display: flex;
      justify-content: center;
      margin-bottom: 18px;
      user-select: none;
    }
    .logoWord {
      display: flex;
      align-items: center;
      gap: 0;
      font-weight: 900;
      letter-spacing: 10px;
      font-size: 56px;
      color: rgba(255,255,255,0.95);
    }
    .logoWord .cCircle{
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: 4px solid rgba(255,255,255,0.92);
      display: inline-block;
      margin: 0 6px 0 -2px; /* tuck into spacing */
      position: relative;
    }
    .logoWord .cCircle:after{
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 60px;
      background: rgba(0,0,0,0.88);
      transform: translate(-50%,-50%); /* creates the “C gap” illusion */
    }

    .startCard {
      width: min(560px, 92vw);
      border-radius: 30px;
      padding: 28px 22px 26px 22px;
      text-align: center;

      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: 0 22px 70px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.08);

      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }

    .startTitle {
      font-size: 44px;
      font-weight: 900;
      margin: 0 0 14px 0;
      letter-spacing: 0.2px;
    }

    .startTip {
      margin: 0 auto 18px auto;
      max-width: 440px;
      font-size: 18px;
      line-height: 1.45;
      color: rgba(255,255,255,0.82);
      font-weight: 600;
    }
    .startTip strong {
      font-weight: 900;
      color: rgba(255,255,255,0.95);
    }

    .pillStack {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
      margin-top: 14px;
    }

    .pillBtn {
      width: min(420px, 82vw);
      padding: 16px 18px;
      border-radius: 999px;
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.2px;
      color: rgba(255,255,255,0.95);

      background: rgba(0,0,0,0.22);
      border: 2px solid rgba(255,255,255,0.85);
      cursor: pointer;

      box-shadow: 0 14px 32px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.10);
      transition: transform 0.08s ease, background 0.12s ease, border 0.12s ease;
    }
    .pillBtn:active { transform: scale(0.99); background: rgba(255,255,255,0.06); }

    .comingSoon {
      margin-top: 14px;
      font-size: 18px;
      color: rgba(255,255,255,0.55);
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    @media (max-width: 380px) {
      .glassBtn { padding: 9px 12px; font-size: 14px; }
      .logoWord { font-size: 46px; letter-spacing: 8px; }
      .logoWord .cCircle{ width: 38px; height: 38px; border-width: 4px; }
      .startTitle { font-size: 38px; }
      .pillBtn { font-size: 20px; padding: 14px 16px; }
    }
  </style>
</head>

<body>
<div id="videoContainer">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="flash"></div>

  <!-- Minimal HUD -->
  <div id="hud">
    <div id="counters">
      <div class="big" id="repsText">Reps: 0</div>
      <div class="small" id="noRepsText">No Reps: 0</div>
      <div class="small" id="tinyStatus" style="margin-top:8px; opacity:0.7;">Ready</div>
    </div>

    <div id="controls">
      <button id="targetMissBtn" class="glassBtn red" type="button">Target Miss</button>
      <button id="resetBtn" class="glassBtn" type="button">Reset</button>
      <button id="flipBtn" class="glassBtn blue" type="button">Flip</button>
    </div>
  </div>

  <!-- Center badge -->
  <div id="badgeWrap">
    <div id="badge">READY</div>
  </div>

  <!-- Start screen -->
  <div id="startScreen">
    <div style="width:min(620px, 92vw); display:flex; flex-direction:column; gap:18px; align-items:center;">
      <div class="logo">
        <div class="logoWord" aria-label="REPCHK">
          <span>R</span><span>E</span><span>P</span>
          <span class="cCircle" aria-hidden="true"></span>
          <span>H</span><span>K</span>
        </div>
      </div>

      <div class="startCard">
        <h1 class="startTitle">Select Division</h1>
        <p class="startTip">
          Tip: place your phone so your full body is visible.
          <br><strong>Rear camera gives best tracking.</strong>
        </p>

        <div class="pillStack">
          <button class="pillBtn" onclick="startApp('women')">Women</button>
          <button class="pillBtn" onclick="startApp('men')">Men</button>
        </div>

        <div class="comingSoon">Coming soon</div>
      </div>
    </div>
  </div>
</div>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const repsText = document.getElementById("repsText");
  const noRepsText = document.getElementById("noRepsText");
  const tinyStatus = document.getElementById("tinyStatus");

  const startScreen = document.getElementById("startScreen");
  const flipBtn = document.getElementById("flipBtn");
  const resetBtn = document.getElementById("resetBtn");
  const targetMissBtn = document.getElementById("targetMissBtn");

  const flashEl = document.getElementById("flash");
  const badgeEl = document.getElementById("badge");

  // ==========================
  // TUNING
  // ==========================
  const DEPTH_MARGIN_PX = 18;
  const THROW_LINE_RATIO = 0.35;
  const RESET_LINE_RATIO = 0.55;
  const MIN_TIME_BETWEEN_REPS_MS = 450;

  // Clean look
  const SHOW_SKELETON = false; // set true if you want the dots/lines back

  // ==========================
  // Counters
  // ==========================
  let reps = 0;     // GOOD reps only
  let noReps = 0;

  // Rep-cycle state
  let depthReachedThisCycle = false;
  let throwHigh = false;
  let lastRepTime = 0;

  // Camera/pose
  let currentFacing = "environment";
  let currentStream = null;
  let pose = null;

  let rafId = null;
  let isProcessing = false;
  let started = false;

  function updateCounters() {
    repsText.textContent = `Reps: ${reps}`;
    noRepsText.textContent = `No Reps: ${noReps}`;
  }

  function flash(color) {
    flashEl.classList.remove("flash");
    flashEl.style.background = color;
    void flashEl.offsetWidth;
    flashEl.classList.add("flash");
  }

  function showBadge(text, type) {
    badgeEl.classList.remove("show", "good", "bad");
    badgeEl.textContent = text;
    if (type === "good") badgeEl.classList.add("good");
    if (type === "bad") badgeEl.classList.add("bad");
    void badgeEl.offsetWidth;
    badgeEl.classList.add("show");
  }

  function setStatus(text) {
    tinyStatus.textContent = text;
  }

  function resetCycleOnly() {
    depthReachedThisCycle = false;
    throwHigh = false;
  }

  function hardResetCounts() {
    reps = 0;
    noReps = 0;
    lastRepTime = 0;
    resetCycleOnly();
    updateCounters();
    setStatus("Reset ✅");
    showBadge("RESET", "");
  }

  resetBtn.addEventListener("click", hardResetCounts);

  targetMissBtn.addEventListener("click", () => {
    noReps += 1;
    updateCounters();
    setStatus("NO REP ❌ (target miss)");
    showBadge("NO REP", "bad");
    flash("rgba(255,60,60,0.22)");

    // prevent immediate auto-trigger from same throw
    lastRepTime = Date.now();
    resetCycleOnly();
  });

  function startApp(division) {
    startScreen.style.display = "none";
    started = true;
    updateCounters();
    setStatus("Ready");
    initPoseOnce();
    startWithFacing("environment");
  }

  function initPoseOnce() {
    if (pose) return;

    pose = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    pose.onResults(onResults);
  }

  function stopLoop() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }

  function stopStream() {
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
    }
  }

  async function startWithFacing(facing) {
    stopLoop();
    stopStream();

    setStatus("Switching...");

    const tryConstraints = [
      { video: { facingMode: { exact: facing }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
      { video: { facingMode: { ideal: facing }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
    ];

    let stream = null;
    let lastErr = null;

    for (const c of tryConstraints) {
      try {
        stream = await navigator.mediaDevices.getUserMedia(c);
        break;
      } catch (e) {
        lastErr = e;
      }
    }

    if (!stream) {
      if (facing === "environment") {
        setStatus("Rear blocked — using front");
        return startWithFacing("user");
      }
      setStatus("Camera error");
      console.error(lastErr);
      return;
    }

    currentStream = stream;
    video.srcObject = currentStream;

    try { await video.play(); } catch (_) {}

    currentFacing = facing;
    setStatus(`Camera: ${currentFacing === "environment" ? "Rear" : "Front"}`);

    resetCycleOnly();
    runLoop();
  }

  function runLoop() {
    const tick = async () => {
      rafId = requestAnimationFrame(tick);

      if (!pose || !started) return;
      if (isProcessing) return;
      if (video.readyState < 2) return;

      isProcessing = true;
      try {
        await pose.send({ image: video });
      } catch (e) {
      } finally {
        isProcessing = false;
      }
    };
    tick();
  }

  flipBtn.addEventListener("click", async () => {
    if (!started) return;
    const next = (currentFacing === "environment") ? "user" : "environment";
    await startWithFacing(next);
  });

  function onResults(results) {
    if (!video.videoWidth || !video.videoHeight) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

    if (!results.poseLandmarks) {
      setStatus("No person detected");
      return;
    }

    const lm = results.poseLandmarks;

    // ===== Depth line + hip marker (kept functional but subtle) =====
    const leftHipY  = lm[23].y * canvas.height;
    const rightHipY = lm[24].y * canvas.height;
    const leftKneeY = lm[25].y * canvas.height;
    const rightKneeY= lm[26].y * canvas.height;

    const hipY  = Math.max(leftHipY, rightHipY);
    const kneeY = Math.max(leftKneeY, rightKneeY);

    const depthGoodNow = hipY > (kneeY + DEPTH_MARGIN_PX);
    if (depthGoodNow) depthReachedThisCycle = true;

    // Knee line
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = 6;
    ctx.strokeStyle = depthReachedThisCycle ? "rgba(0,255,140,0.85)" : "rgba(255,255,255,0.25)";
    ctx.moveTo(0, kneeY);
    ctx.lineTo(canvas.width, kneeY);
    ctx.stroke();

    // Hip dot
    const hipX = ((lm[23].x + lm[24].x) / 2) * canvas.width;
    ctx.beginPath();
    ctx.fillStyle = depthGoodNow ? "rgba(0,255,140,0.85)" : "rgba(255,255,255,0.18)";
    ctx.arc(hipX, hipY, 9, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // ===== Throw timing (wrists) =====
    const leftWristY = lm[15].y * canvas.height;
    const rightWristY = lm[16].y * canvas.height;
    const wristY = Math.min(leftWristY, rightWristY);

    const throwLineY = canvas.height * THROW_LINE_RATIO;
    const resetLineY = canvas.height * RESET_LINE_RATIO;

    const now = Date.now();

    if (!throwHigh && wristY < throwLineY) {
      if (now - lastRepTime > MIN_TIME_BETWEEN_REPS_MS) {

        if (depthReachedThisCycle) {
          reps += 1;
          updateCounters();
          setStatus("GOOD REP ✅");
          showBadge("GOOD REP", "good");
          flash("rgba(0,255,140,0.25)");
        } else {
          noReps += 1;
          updateCounters();
          setStatus("NO REP ❌ (depth)");
          showBadge("NO REP", "bad");
          flash("rgba(255,60,60,0.22)");
        }

        throwHigh = true;
        lastRepTime = now;
        depthReachedThisCycle = false;
      }
    }

    if (throwHigh && wristY > resetLineY) {
      throwHigh = false;
    }

    // Optional skeleton overlay (off for premium look)
    if (SHOW_SKELETON) {
      drawConnectors(ctx, lm, POSE_CONNECTIONS, { color: "#00FF00", lineWidth: 2 });
      drawLandmarks(ctx, lm, { color: "#FF0000", lineWidth: 1 });
    }
  }
</script>
</body>
</html>
