<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Wall Ball Judge</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{
      --flipGreen: #087862;
      --red: rgba(255, 90, 90, 0.95);
      --glassBorder: rgba(255,255,255,0.18);
      --textDim: rgba(255,255,255,0.78);

      --greenFlash: rgba(0, 255, 140, 0.25);
      --redFlash: rgba(255, 60, 60, 0.22);
    }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial;
      background: #000;
      color: #fff;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
      letter-spacing: 0.1px;
    }

    #videoContainer {
      position: fixed;
      inset: 0;
      overflow: hidden;
      background: #000;
    }

    video, canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      transform: translate(-50%, -50%);
    }

    /* ===== Fullscreen flash ===== */
    #flash {
      position: absolute;
      inset: 0;
      z-index: 30;
      pointer-events: none;
      opacity: 0;
    }
    @keyframes flashAnim {
      0% { opacity: 0; }
      18% { opacity: 1; }
      100% { opacity: 0; }
    }
    #flash.flash { animation: flashAnim 240ms ease-out; }

    /* ===== Minimal top HUD (safe-area aware) ===== */
    #hud {
      position: absolute;
      top: calc(12px + env(safe-area-inset-top));
      left: calc(12px + env(safe-area-inset-left));
      right: calc(12px + env(safe-area-inset-right));
      z-index: 40;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      pointer-events: none;
    }

    #counters {
      pointer-events: none;
      padding: 10px 12px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      border: 1px solid rgba(255,255,255,0.16);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      min-width: 140px;
      max-width: 45vw;
    }

    #counters .big {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.2px;
      line-height: 1.05;
    }
    #counters .small {
      margin-top: 6px;
      font-size: 14px;
      color: var(--textDim);
      font-weight: 600;
      letter-spacing: 0.15px;
      line-height: 1.2;
      white-space: normal;
    }

    #controls {
      pointer-events: auto;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
      max-width: 60vw;
    }

    .glassBtn {
      padding: 10px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.05));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.92);
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.2px;
      cursor: pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
      transition: transform 0.08s ease, background 0.12s ease, border 0.12s ease, opacity 0.12s ease;
      user-select: none;
      white-space: nowrap;
    }
    .glassBtn:active { transform: scale(0.99); }

    .glassBtn.red {
      background: linear-gradient(180deg, rgba(255,90,90,0.62), rgba(255,90,90,0.28));
      border-color: rgba(255,90,90,0.35);
    }

    .glassBtn.green {
      background: linear-gradient(180deg, rgba(8,120,98,0.85), rgba(8,120,98,0.45));
      border-color: rgba(8,120,98,0.45);
    }
    .glassBtn.green.off {
      opacity: 0.62;
      border-color: rgba(255,255,255,0.18);
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
    }

    /* ===== Big centered feedback badge ===== */
    #badgeWrap {
      position: absolute;
      inset: 0;
      z-index: 45;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    #badge {
      opacity: 0;
      transform: translateY(8px) scale(0.985);
      padding: 14px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 20px 60px rgba(0,0,0,0.55);
      font-weight: 900;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      font-size: 22px;
      color: rgba(255,255,255,0.92);
    }

    @keyframes badgeInOut {
      0%   { opacity: 0; transform: translateY(10px) scale(0.98); }
      12%  { opacity: 1; transform: translateY(0) scale(1.00); }
      80%  { opacity: 1; transform: translateY(0) scale(1.00); }
      100% { opacity: 0; transform: translateY(8px) scale(0.99); }
    }
    #badge.show { animation: badgeInOut 900ms ease-out; }
    #badge.good { border-color: rgba(0,255,140,0.35); background: rgba(0,255,140,0.12); }
    #badge.bad  { border-color: rgba(255,60,60,0.40); background: rgba(255,60,60,0.10); }

    /* ===== Start screen ===== */
    #startScreen {
      position: absolute;
      inset: 0;
      z-index: 50;
      display: flex;
      justify-content: center;
      align-items: center;

      /* strong outer padding */
      padding:
        calc(34px + env(safe-area-inset-top))
        calc(34px + env(safe-area-inset-right))
        calc(34px + env(safe-area-inset-bottom))
        calc(34px + env(safe-area-inset-left));
      box-sizing: border-box;

      background:
        radial-gradient(85% 70% at 15% 20%, rgba(0, 255, 140, 0.18), transparent 60%),
        radial-gradient(85% 70% at 85% 30%, rgba(0, 255, 140, 0.14), transparent 62%),
        radial-gradient(90% 75% at 60% 90%, rgba(0, 255, 140, 0.12), transparent 55%),
        rgba(0,0,0,0.88);
    }

    /* full-width wrapper so card can be constrained precisely */
    .startWrap {
      width: 100%;
      max-width: 640px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      align-items: center;
    }

    .logoImgWrap {
      display: flex;
      justify-content: center;
      margin-bottom: 4px;
      user-select: none;
      width: 100%;
    }
    .logoImg {
      width: min(520px, 86vw);
      height: auto;
      display: block;
      filter: drop-shadow(0 18px 40px rgba(0,0,0,0.55));
    }

    /* IMPORTANT: hard cap based on viewport minus guaranteed margins */
    .startCard {
      width: min(560px, calc(100vw - 72px - env(safe-area-inset-left) - env(safe-area-inset-right)));
      border-radius: 30px;
      padding: 28px 22px 26px 22px;
      text-align: center;

      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: 0 22px 70px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.08);

      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }

    .startTitle {
      font-size: 44px;
      font-weight: 900;
      margin: 0 0 14px 0;
      letter-spacing: 0.2px;
    }

    .startTip {
      margin: 0 auto 18px auto;
      max-width: 440px;
      font-size: 18px;
      line-height: 1.45;
      color: rgba(255,255,255,0.82);
      font-weight: 600;
    }
    .startTip strong {
      font-weight: 900;
      color: rgba(255,255,255,0.95);
    }

    .pillStack {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
      margin-top: 14px;
    }

    .pillBtn {
      width: 100%;
      max-width: 420px;
      padding: 16px 18px;
      border-radius: 999px;
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.2px;
      color: rgba(255,255,255,0.95);

      background: rgba(0,0,0,0.22);
      border: 2px solid rgba(255,255,255,0.85);
      cursor: pointer;

      box-shadow: 0 14px 32px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.10);
      transition: transform 0.08s ease, background 0.12s ease, border 0.12s ease;
    }
    .pillBtn:active { transform: scale(0.99); background: rgba(255,255,255,0.06); }

    .comingSoon {
      margin-top: 14px;
      font-size: 18px;
      color: rgba(255,255,255,0.55);
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    @media (max-width: 430px) {
      #controls { gap: 8px; max-width: 66vw; }
      .glassBtn { padding: 9px 12px; font-size: 14px; letter-spacing: 0.15px; }
      #counters { max-width: 52vw; }

      /* even more guaranteed space on small screens */
      .startCard {
        width: calc(100vw - 84px - env(safe-area-inset-left) - env(safe-area-inset-right));
      }
    }
    @media (max-width: 380px) {
      #controls { max-width: 70vw; }
      .glassBtn { padding: 8px 10px; font-size: 13px; }
      .startTitle { font-size: 38px; }
      .pillBtn { font-size: 20px; padding: 14px 16px; }

      #startScreen {
        padding:
          calc(30px + env(safe-area-inset-top))
          calc(30px + env(safe-area-inset-right))
          calc(30px + env(safe-area-inset-bottom))
          calc(30px + env(safe-area-inset-left));
      }
      .startCard {
        width: calc(100vw - 92px - env(safe-area-inset-left) - env(safe-area-inset-right));
      }
    }
  </style>
</head>

<body>
<div id="videoContainer">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="flash"></div>

  <div id="hud">
    <div id="counters">
      <div class="big" id="repsText">Reps: 0</div>
      <div class="small" id="noRepsText">No Reps: 0</div>
      <div class="small" id="tinyStatus" style="margin-top:8px; opacity:0.7;">Ready</div>
    </div>

    <div id="controls">
      <button id="guidesBtn" class="glassBtn green" type="button">Guides</button>
      <button id="targetMissBtn" class="glassBtn red" type="button">Target Miss</button>
      <button id="resetBtn" class="glassBtn" type="button">Reset</button>
      <button id="flipBtn" class="glassBtn green" type="button">Flip</button>
    </div>
  </div>

  <div id="badgeWrap">
    <div id="badge">READY</div>
  </div>

  <div id="startScreen">
    <div class="startWrap">
      <div class="logoImgWrap">
        <img class="logoImg" src="repchk_logo.png" alt="REPCHK logo" />
      </div>

      <div class="startCard">
        <h1 class="startTitle">Select Division</h1>
        <p class="startTip">
          Tip: place your phone so your full body is visible.
          <br><strong>Rear camera gives best tracking.</strong>
        </p>

        <div class="pillStack">
          <button class="pillBtn" onclick="startApp('women')">Women</button>
          <button class="pillBtn" onclick="startApp('men')">Men</button>
        </div>

        <div class="comingSoon">Coming soon</div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const repsText = document.getElementById("repsText");
  const noRepsText = document.getElementById("noRepsText");
  const tinyStatus = document.getElementById("tinyStatus");

  const startScreen = document.getElementById("startScreen");
  const flipBtn = document.getElementById("flipBtn");
  const resetBtn = document.getElementById("resetBtn");
  const targetMissBtn = document.getElementById("targetMissBtn");
  const guidesBtn = document.getElementById("guidesBtn");

  const flashEl = document.getElementById("flash");
  const badgeEl = document.getElementById("badge");

  const DEPTH_MARGIN_PX = 18;
  const THROW_LINE_RATIO = 0.35;
  const RESET_LINE_RATIO = 0.55;
  const MIN_TIME_BETWEEN_REPS_MS = 450;

  let guidesOn = true;

  function syncGuidesUI() {
    guidesBtn.classList.toggle("off", !guidesOn);
  }
  guidesBtn.addEventListener("click", () => {
    guidesOn = !guidesOn;
    syncGuidesUI();
  });
  syncGuidesUI();

  let reps = 0;
  let noReps = 0;

  let depthReachedThisCycle = false;
  let throwHigh = false;
  let lastRepTime = 0;

  let currentFacing = "environment";
  let currentStream = null;
  let pose = null;

  let rafId = null;
  let isProcessing = false;
  let started = false;

  function updateCounters() {
    repsText.textContent = `Reps: ${reps}`;
    noRepsText.textContent = `No Reps: ${noReps}`;
  }

  function flash(color) {
    flashEl.classList.remove("flash");
    flashEl.style.background = color;
    void flashEl.offsetWidth;
    flashEl.classList.add("flash");
  }

  function showBadge(text, type) {
    badgeEl.classList.remove("show", "good", "bad");
    badgeEl.textContent = text;
    if (type === "good") badgeEl.classList.add("good");
    if (type === "bad") badgeEl.classList.add("bad");
    void badgeEl.offsetWidth;
    badgeEl.classList.add("show");
  }

  function setStatus(text) {
    tinyStatus.textContent = text;
  }

  function resetCycleOnly() {
    depthReachedThisCycle = false;
    throwHigh = false;
  }

  function hardResetCounts() {
    reps = 0;
    noReps = 0;
    lastRepTime = 0;
    resetCycleOnly();
    updateCounters();
    setStatus("Reset ✅");
    showBadge("RESET", "");
  }

  resetBtn.addEventListener("click", hardResetCounts);

  targetMissBtn.addEventListener("click", () => {
    noReps += 1;
    updateCounters();
    setStatus("NO REP ❌ (target miss)");
    showBadge("NO REP", "bad");
    flash("rgba(255,60,60,0.22)");

    lastRepTime = Date.now();
    resetCycleOnly();
  });

  function startApp(division) {
    startScreen.style.display = "none";
    started = true;
    updateCounters();
    setStatus("Ready");
    initPoseOnce();
    startWithFacing("environment");
  }

  function initPoseOnce() {
    if (pose) return;

    pose = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    pose.onResults(onResults);
  }

  function stopLoop() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }

  function stopStream() {
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
    }
  }

  async function startWithFacing(facing) {
    stopLoop();
    stopStream();
    setStatus("Switching...");

    const tryConstraints = [
      { video: { facingMode: { exact: facing }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
      { video: { facingMode: { ideal: facing }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
    ];

    let stream = null;
    let lastErr = null;

    for (const c of tryConstraints) {
      try {
        stream = await navigator.mediaDevices.getUserMedia(c);
        break;
      } catch (e) {
        lastErr = e;
      }
    }

    if (!stream) {
      if (facing === "environment") {
        setStatus("Rear blocked — using front");
        return startWithFacing("user");
      }
      setStatus("Camera error");
      console.error(lastErr);
      return;
    }

    currentStream = stream;
    video.srcObject = currentStream;

    try { await video.play(); } catch (_) {}

    currentFacing = facing;
    setStatus(`Camera: ${currentFacing === "environment" ? "Rear" : "Front"}`);

    resetCycleOnly();
    runLoop();
  }

  function runLoop() {
    const tick = async () => {
      rafId = requestAnimationFrame(tick);

      if (!pose || !started) return;
      if (isProcessing) return;
      if (video.readyState < 2) return;

      isProcessing = true;
      try {
        await pose.send({ image: video });
      } catch (e) {
      } finally {
        isProcessing = false;
      }
    };
    tick();
  }

  flipBtn.addEventListener("click", async () => {
    if (!started) return;
    const next = (currentFacing === "environment") ? "user" : "environment";
    await startWithFacing(next);
  });

  function onResults(results) {
    if (!video.videoWidth || !video.videoHeight) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

    if (!results.poseLandmarks) {
      setStatus("No person detected");
      return;
    }

    const lm = results.poseLandmarks;

    const leftHipY  = lm[23].y * canvas.height;
    const rightHipY = lm[24].y * canvas.height;
    const leftKneeY = lm[25].y * canvas.height;
    const rightKneeY= lm[26].y * canvas.height;

    const hipY  = Math.max(leftHipY, rightHipY);
    const kneeY = Math.max(leftKneeY, rightKneeY);

    const depthGoodNow = hipY > (kneeY + DEPTH_MARGIN_PX);
    if (depthGoodNow) depthReachedThisCycle = true;

    if (guidesOn) {
      ctx.save();
      ctx.beginPath();
      ctx.lineWidth = 8;
      ctx.strokeStyle = depthReachedThisCycle ? "rgba(0,255,140,0.95)" : "rgba(255,255,255,0.55)";
      ctx.moveTo(0, kneeY);
      ctx.lineTo(canvas.width, kneeY);
      ctx.stroke();

      const hipX = ((lm[23].x + lm[24].x) / 2) * canvas.width;
      ctx.beginPath();
      ctx.fillStyle = depthGoodNow ? "rgba(0,255,140,0.95)" : "rgba(255,255,255,0.55)";
      ctx.arc(hipX, hipY, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    const leftWristY = lm[15].y * canvas.height;
    const rightWristY = lm[16].y * canvas.height;
    const wristY = Math.min(leftWristY, rightWristY);

    const throwLineY = canvas.height * THROW_LINE_RATIO;
    const resetLineY = canvas.height * RESET_LINE_RATIO;

    const now = Date.now();

    if (!throwHigh && wristY < throwLineY) {
      if (now - lastRepTime > MIN_TIME_BETWEEN_REPS_MS) {

        if (depthReachedThisCycle) {
          reps += 1;
          updateCounters();
          setStatus("GOOD REP ✅");
          showBadge("GOOD REP", "good");
          flash("rgba(0,255,140,0.25)");
        } else {
          noReps += 1;
          updateCounters();
          setStatus("NO REP ❌ (depth)");
          showBadge("NO REP", "bad");
          flash("rgba(255,60,60,0.22)");
        }

        throwHigh = true;
        lastRepTime = now;
        depthReachedThisCycle = false;
      }
    }

    if (throwHigh && wristY > resetLineY) {
      throwHigh = false;
    }

    if (guidesOn) {
      drawConnectors(ctx, lm, POSE_CONNECTIONS, { color: "#00FF00", lineWidth: 2 });
      drawLandmarks(ctx, lm, { color: "#FF0000", lineWidth: 1 });
    }
  }
</script>
</body>
</html>
